<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[园区网基础架构实验手册]]></title>
    <url>%2F2018%2F05%2F13%2F%E5%9B%AD%E5%8C%BA%E7%BD%91%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E5%AE%9E%E9%AA%8C%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[这是实验1的实验手册完善版，有看的朋友不要无脑跟着我的步骤做，不然你会啥都没学到，然后我一首凉凉送给你。 实验分析1、首先1-3步实验需求，在三台交换机之间动态协商建立trunk，然后建立VTP，最后创建Vlan，然后在接入层将连接PC的接口划分为access口。2、4-5步的需求，在核心交换机上（架构比较小，不需要汇聚）创建三层接口使得可以和NAT路由器互通，并且在交换机和NAT路由器上创建地址池。PC1通过Vlan 10向核心交换机获取地址，PC2和PC3向NAT路由器获取，因为DHCP请求包是广播包，而核心交换机开启了路由功能，隔绝广播域，所以需要在核心交换机上开启DHCP 中继功能：PC的广播请求发给Core，Core收到后单播给NAT路由器。而路由器需要单播回复给在Core的Vlan 20和Vlan 30的管理地址，所以需要有路由条目，这时候需要整网通告路由。3、第6步配置VTY。4、第7步拒绝PC2的流量，可以将PC2的网线拔了，简单粗暴。也可以在Core的C接口上配置ACL，拒绝PC2的流量。其他方法自己想，上过路由的多少应该知道一点，没上过的我说了也没用。要注意：这里的ACL不可以配在Access2上，因为Access2没有开启路由功能，而ACL是要匹配路由的。5、更改域名后，因为VTP域名不一致，动态协商建立trunk会失败（改完域名后关掉接口再打开），所以可以关闭动态协商，手动建立trunk。 实验配置加速命令：1234no ip domain lookupLine console 0logging synchronousexec-timeout 0 0 123456Core(config)#int f0/17Core(config-if)#switchport mode dynamic desirable //动态协商Core(config-if)#switchport trunk encapsulation dot1qCore(config-if)#int f0/21Core(config-if)#switchport mode dynamic desirableCore(config-if)#switchport trunk encapsulation dot1q 1234Access1(config)#int f0/12Access1(config-if)#switchport mode dynamic autoAccess1(config-if)#switchport trunk allow vlan allAccess1(config-if)#switchport trunk native vlan 1 1234Access2(config)#int f0/12Access2(config-if)#switchport mode dynamic autoAccess2(config-if)#switchport trunk allow vlan allAccess2(config-if)#switchport trunk native vlan 1 123Core(config)#vtp mode serverCore(config)#vtp domain sovand.comCore(config)#vtp password 123 123Access1(config)#vtp mode clientAccess1(config)#vtp domain sovand.comAccess1(config)#vtp password 123 123Access2(config)#vtp mode transparentAccess2(config)#vtp domain sovand.comAccess2(config)#vtp password 123 123Core(config)#vlan 10Core(config)#vlan 20Core(config)#vlan 30 在Access1上：show vlan 查看vlan是否同步，正常可以同步。在Access2上查看，正常不可以同步。 123Access1(config)#int f0/5Access1(config-if)#switchport mode accessAccess1(config-if)#switchport access vlan 10 12345678Access2(config)#vlan 20Access2(config)#vlan 30Access2(config)#int f0/8Access2(config-if)#switchport mode accessAccess2(config-if)#switchport access vlan 20Access2(config-if)#int f0/9Access2(config-if)#switchport mode accessAccess2(config-if)#switchport access vlan 30 实现三层互通和配置vlan的管理地址1234567891011121314151617181920Core(config)#ip routing //打开三层交换机路由功能Core(config)#int f0/11Core(config-if)#no switchport //打开接口三层功能Core(config-if)#ip add 24.24.24.4 255.255.255.0Core(config-if)#no shCore(config)#int vlan 20Core(config-if)#ip add 10.1.20.1 255.255.255.0Core(config-if)#no shCore(config-if)#int vlan 30Core(config-if)#ip add 10.1.30.1 255.255.255.0Core(config-if)#no shCore(config-if)#int vlan 10Core(config-if)#ip add 10.1.10.1 255.255.255.0Core(config-if)#no shCore(config)#router ospf 1Core(config-router)#router-id 4.4.4.4Core(config-router)#network 24.24.24.0 0.0.0.255 area 0Core(config-router)#network 10.1.10.0 0.0.0.255 area 0Core(config-router)#network 10.1.20.0 0.0.0.255 area 0Core(config-router)#network 10.1.30.0 0.0.0.255 area 0 123456789Router1(config)#int f0/0Router1(config-if)#ip add 24.24.24.2 255.255.255.0Router1(config-if)#no shRouter1(config-if)#int f0/1Router1(config-if)#ip add 12.12.12.2 255.255.255.0Router1(config-if)#no shRouter1(config)#router ospf 1Router1(config-router)#network 24.24.24.0 0.0.0.255 area 0Router1(config-router)#default-information originate always 配置地址池1234567Core(config)#ip dhcp pool 10 //10是地址池的名字Core(dhcp-config)#network 10.1.10.0 255.255.255.0Core(dhcp-config)#default-router 10.1.10.1Core(config)#int vlan 20Core(config-if)#ip helper-address 24.24.24.2 //中继到NAT路由器的入接口Core(config)#int vlan 30Core(config-if)#ip helper-address 24.24.24.2 123456Router1(config)#ip dhcp pool 20Router1(dhcp-config)#network 10.1.20.0 255.255.255.0Router1(dhcp-config)#default-router 10.1.20.1Router1(config)#ip dhcp pool 30Router1(dhcp-config)#network 10.1.30.0 255.255.255.0Router1(dhcp-config)#default-router 10.1.30.1 在PC上:123No ip routingint f0/0Ip add dhcp 此时分析DHCP报文交互，在Core上：12debug ip dhcp server eventsDebug ip dhcp server packet 或者做端口镜像（可不做），也是在Core上：12Core(config)#monitor session 1 source interface f0/11 both //设置捕获数据源端口Core(config)#monitor session 1 destination interface f0/5 //设置目的端口，此时只需要拉一根网线，一边接f0/5，另一边接自己的电脑，打开Wireshark捕捉本地连接，就可以抓到包，此时在PC上ip add dhcp ，就可以抓到DHCP报文。 由图中可以看出Core中继了DHCP的请求。 PC间互通，并且可以访问Router21234567Router1(config)#access-list 1 permit 10.1.0.0 0.0.255.255Router1(config)#ip nat inside source list 1 int f0/1 overloadRouter1(config)#int f0/1Router1(config-if)#ip nat outsideRouter1(config)#int f0/0Router1(config-if)#ip nat insideRouter1(config)#ip route 0.0.0.0 0.0.0.0 12.12.12.7 1234Router2(config)#int f0/1Router2(config-if)#ip add 12.12.12.7 255.255.255.0Router2(config-if)#int lo1Router2(config-if)#ip add 2.2.2.2 255.255.255.0 实现远程管理———密码登录方式——–1234Core(config)#line vty 0 4Core(config-line)#password 123Core(config-line)#loginCore(config)#enable password abc123 ———-账号密码登录方式————-12345Core(config)#username haha password 123Core(config)#line vty 0 4Core(config-line)#login localCore(config)#enable password abc123 //设置进入特权模式的密码，没设置无法进入Core(config)#service password-encryption //加密全局密码 拒绝PC2的异常流量1234Core(config)#access-list 1 deny 10.1.20.0 0.0.0.255Core(config)#access-list 1 permit anyCore(config)#int f0/21Core(config-if)#ip access-group 1 in 更改Access1的VTP域名1234Access1(config)#vtp domain sovand.orgAccess1(config)#int f0/12Access1(config-if)#shAccess1(config-if)#no sh //此时show int trunk发现trunk已经没了 ——-关闭之前配置的动态协商，手动建立trunk——1234Access1(config-if)#no switchport mode dynamic autoAccess1(config-if)#switchport mode trunkAccess1(config-if)#switchport trunk allowed vlan allAccess1(config-if)#switchport trunk native vlan 1 Core(config)#int f0/17 Core(config-if)#no switchport mode dynamic desirable Core(config-if)# switchport mode trunk Core(config-if)#switchport trunk encapsulation dot1q 后续实验手册会陆续发布到个人博客中，敬请期待！]]></content>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全国大学生信息安全竞赛部分writeup]]></title>
    <url>%2F2018%2F05%2F01%2F%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[干了两天破题，真切体会了web狗的无奈，闲来无聊只能去做杂项，看看流量分析。还有剧毒的华为云，无力吐槽。 WEBEASYWEB先注册账号，进入后提示只有admin才能得到flag，F12打开源码，发现password字段有默认值，删除默认值，账号admin，密码为空，进入页面，得到flag。 MISC验证码进入链接，输入队伍token，再输入一个验证码，得到flag。 寻找入侵者根据题目提示，打开attack.pcapng，选择统计的已解析地址，选择出所有MAC地址，复制出来，用脚本将后面的设备名删除，然后作为密码字典，拿到aircrack-ng上爆密码。得到密码：题目说让我们解开数据包，而且握手包特别大，所以肯定隐藏了什么信息，利用aircrack-ng自带的解密工具，解出被加密的压缩包。接下来分析解密的流量包，发现有很多HTTP协议，过滤出HTTP协议，发现最后面隐藏了key.rar，搜索key.rar，得到一个链接。双击链接可以下载一个key.rar文件，解压得到key.pcap，根据之前获得的黑客的MAC地址，过滤(规则为：wlan.sa == 获得的MAC)，得到flag。Flag为！号后面的那串字符串。题目相关资料：密码：38yk```123456789### PICTURE ###观察图片，说是让我们展示代码，所以应该是要查看图片源码。不管怎么样，图片题一般都先拿去binwalk一下，得到两个文件，将第一个文件扔到winhex里面查看图片源码，可以看到一串base64编码。在线网站解码后应该是一个zip压缩包的源码。将4B50改成504B，发现压缩包破损，个人觉得应该是在线网站解码的格式有问题，于是自己写了一个脚本解码，果然就可以了。根据提示密码在箭头的左边，各种尝试无果，搜索ZeroDivisionError报错详情。![misc6](全国大学生信息安全竞赛部分writeup/misc6.png)![misc7](全国大学生信息安全竞赛部分writeup/misc7.png)尝试输入integer division or modulo by zero，发现解密出来了，得到code文件。拿到binwalk分析，发现这是一个uudecode编码，将begin和end之间的字符串复制到在线解密网站，得到flag。![misc8](全国大学生信息安全竞赛部分writeup/misc8.png)在线解密网站： http://web.chacuo.net/charsetuuencode1题目材料： https://pan.baidu.com/s/1AWusibhPkmy1KBiFKpn3Hw 密码：rr7h12345678## CRYPTO ##### Flag_in_your_hand ###在本题中通过下载得到了两个文件。打开index.Html发现他通过调用script-min.js来对输入进行操作。![crypto1](全国大学生信息安全竞赛部分writeup/crypto1.png)这是就要分析script-min.js，打开script-min.js，通过对文件的分析找到了一个比较函数。![crypto2](全国大学生信息安全竞赛部分writeup/crypto2.png)A= 100, 116, 101, 48, 118, 104, 102, 120, 117, 108, 119, 124;通过ascii表转换a=dte0vhfxulw|,发现最后这个符号应该不太对，继续进行凯撒发现将a-3的ascii进行匹配，得出s=aqb-security。将aqb-security作为flag进行提交，通过。题目材料： https://pan.baidu.com/s/1BCH3UAmddU0uVJ_BNIQ9cw 密码：a000`]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杂项之流量分析]]></title>
    <url>%2F2018%2F04%2F04%2F%E6%9D%82%E9%A1%B9%E4%B9%8B%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[这两天做了几题流量分析，这脑洞大的，让人头皮发麻。。。 这次的题目出自蓝鲸安全，是一个很棒的平台，有题库有视频教程，值得我安利一下。题目链接：http://whalectf.xin/challenges视频链接：http://www.whaledu.com/course/explore/NS01 流量分析下载一个抓包文件，点击统计选项的协议分级，可以看到HTTP的流量占了很多，其中传输了图片、媒体文件和gif动图等。根据直觉，给了这么多图片，所以东西应该不会藏在图片中；再者还有，题目给了一个压缩包，解压出来是抓包文件，但是文件很小，没必要压缩，而且其他题目好几兆的文件都没压缩。根据这两个猜想，觉得压缩包有点猫腻，浏览一遍HTTP数据后，发现最后面有一个压缩包。bingo，选择http的数据部分，导出分组字节流，保存为.zip文件。压缩包解压出来发现是一个空word，本以为是隐藏了字符，看了一下发现确实什么都没有。但是文档名字是“情报”，所以我觉得东西肯定在这里，这时候脑洞大开，打开详细信息看一下，发现flag在备注里面，这可真是太秀了！！！还好最近买了点核桃补补脑子，不然都跟不上节奏了。 A记录打开抓包文件，提示捕获文件在中间被剪断，剩下的包都是wifi协议的包。搜索EAPol，发现有3个包，拿去工具上解出密码，用kali自带的Aircrack-ng查看一下信息。加密方式为WAP，ESSID为0719。接下来爆破密码，用字典工具生成一个字典，跑出来密码为8个8，命令是：aircrack-ng shipin.cap -w passwd.txt。接下来用获得的密码和ESSID来还原被加密的数据包，命令是：airdecap-ng shipin.cap -e 0719 -p 88888888.命令执行完成后，有16个包被解密出来，这就是原始的数据包。题目说第一条A记录，那就过滤出DNS包，第二个包就是A记录的包，追踪UDP流，获得flag。 Password打开文件，有95个TCP文件，其中包含PSH和ACK位置1的包，PSH功能是快速推送数据至应用层，所以这题的密码应该是用TCP的PSH位来传输的。追踪TCP流，获得关键信息。这里有密码输入界面，不过下面提示密码错误。。。。瞬间尬住-，但是信息又只可能在这里，所以继续对这个流进行操作，这里的数据是编码成ASCII码显示，而密码中包含好多个点，个人觉得有猫腻，用十六进制打开，发现点对应的十六进制居然是7F。讲道理应该没那么大才对，算了一下7F是127，看了下ASCII表，127是DEL，就是删除键，果然，将点换成删除，输入，正确！]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用SAM破解系统登录密码]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%88%A9%E7%94%A8SAM%E7%A0%B4%E8%A7%A3%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天的网络攻防课讲了一个有意思的东西，随手来测试一下。 SAM(Security Account Manager，简称SAM)是windows的口令文件，存储了系统账户的信息(所有组、帐户的信息，包括密码的HASH、帐户的SID等)，我们可以根据获取的SAM文件爆出终端所有的账户和密码。 windows的SAM文件放在C:\Windows\System32\config里面，但是这个路径下的文件在登录进系统时被系统进程占用了，我们无法进行任何操作，所以需要从其他地方获取该文件。获取的途径有两种：1、C:\Windows\Repair里面会有一个备份。2、如果备份被删掉的话，可以用进入PE系统，这时候就没有任何进程占用该文件了，可以拷出来。PS：拷文件时把同目录下的SYSTEM也拷出来，后面破解要用。 Windows 对同一用户口令采用两套单向散列函数进行运算，即单向LM散列算法和单向NT散列算法，两种算法的结果都保存在SAM文件中。这两种算法产生的HASH值就是我们所要利用的。具体原理是：两种算法根据原始密码生成散列值，我们利用掩码攻击、暴力枚举或字典攻击等方式将生成的密码进行同样算法的运算，生成的散列值与SAM文件中的散列值比对，如果一样就是正确的密码，将密码输出。 下面进行简单的实际操作 这里用到的工具是：saminside，这里附上下载地址：https://pan.baidu.com/s/1s0LP2IPO3LLzYPny0iQhrA 密码：44751、首先将SAM和SYSTEM文件都拷到saminside工具的Tools目录下（避免出现一些意外的错误）。2、打开软件，在file框选择第一个：Imprrt SAM and SYSTEM Register File ，然后选择SAM和SYSTEM文件。3、选择好文件后，要选择加密算法，看文件的HASH字段是LM还是NT，我这里是NT，所以点击工具，切换为NT算法。4、接下来点击OPtions，选择要进行的攻击方式，这里我选择暴力破解，因为我知道自己的密码，定个范围就好了。5、接下来等着出结果了，密码不难的话一下子就跑出来了。6、还有一种方法是，在file框选择第二个：Import SAM Rigistry and SYSKEY File，然后选择SAM文件。7、下一步会让我们选择key文件，这里解释一下该文件：Windows系统也会采用了更为安全的SYSKEY加密方式保护登录密码，对密码进行二次加密，使得L0phtCrack这样的逆天神器也无能为力，SYSKEY二次加密后也保存在SYSTEM文件中。讲到这里思路应该很清晰了，将之前拷贝的SYSTEM文件反向提取出key文件，然后拿key文件跑出密码。key文件的获取方式是：在Tools下有一个GetSyskey.exe程序，在该目录下打开cmd界面，输入：GetSyskey.exe SYSTEM 文件名就会输出key文件。这个方法很明显，当系统采用SYSKEY进行二次加密时用的，而且用之前要先进行第一步的文件导入。这里我遇到一个小bug，我不管输入什么文件名，输出的文件都叫StartKey.key，我猜可能是软件的问题，不过无伤大雅。各位大黑阔们如果解决了这个问题记得在下面评论告诉我一下。感觉自己密码好危险，快去改掉！！！ 有不懂得可以在下面留言，我会尽快回复的。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moctf部分题目writeup]]></title>
    <url>%2F2018%2F03%2F21%2Fmoctf%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup%2F</url>
    <content type="text"><![CDATA[moctf是理工和集大的大佬们搭建的平台，下面是一些我做出来的题目的writeup。 题目链接 MISC捉迷藏题目给了一个zhuomicang.zip的压缩包，解压得到flag.txt和2.jpg。果断打开flag.txt，里面的内容是：1bW9jdGZ7QnVfeUEwX3QxX2oxYTB9 看这架势应该是base64,拿去在线网站解一下，网址为：http://www1.tc711.com/tool/BASE64.htm解出来看起来像是flag了:1moctf&#123;Bu_yA0_t1_j1a0&#125; 但是仔细看，内容是不要提交，不管了先交，万一出题人想皮一下呢。交上去，报错。那只能看图片了，先用十六进制编辑器看一下，发现图片里面还有一个flag.txt。拿去kali里面binwalk一下，得到一个压缩包，解压得到flag.txt。里面是一串数字：1109 111 99 116 102 123 104 49 100 51 95 97 78 100 95 115 51 51 75 125 猜想应该是十进制转ASCII码，工具解一下，得到flag：moctf{h1d3_aNd_s33K}工具地址：链接：https://pan.baidu.com/s/1IDsoRb40Tv4TAnQxlEAOQQ 密码：kch0 我可是黑客点进链接是一张图片，图片上写了审查元素，按了下F12，没有东西。好吧，保存下来，用十六进制编辑器打开，发现最后面有料：moctf{e4sy_1ma9e_m1sc}。 光阴似箭打开链接，是一张png的动图，保存为gif。然后拿去gif分解网站分解一下得到flag：在线gif分解网站 扫扫出奇迹二维码扫描工具，扫一下得到flag：moctf{qr_code_1s_1n_1t} 杰斯的魔法打开链接，是一串js代码，document.write()方法是用来向网页输出内容的。所以，复制一下扔控制台，得到flag。 百变flag打开链接，发现左上角有一小张图片，但是右键不能保存，返回题目链接，右键保存，得到一张f1ag.png。用十六进制编辑器查看，发现后面有一个f1ag.exe，于是拿到kali分解，提取出压缩包，里面就是f1ag.exe，但是打不开。这时候打开十六进制编辑器（WinHex），在最后面发现重要线索。图片中的数据好像被反过来了，这时候想到提示：特殊文件头+简单字符串编程，应该就是要把数据反回来，再加上文件头。python启动123output = inputFile[::-1]outputFile = open(&apos;output&apos;, &apos;wb&apos;)outputFile.write(output) 运行后得到output文件，用WinHex查看发现已经反回来了，而且文件头已经有了：FFD8FFE1，是JPEG的文件格式，所以加上.jpeg后缀就得到flag了。 歌曲下载压缩包，解压得到apple.mp3和apple.png。图片中间藏着一个二维码，扫描出来是一串Unicode编码：1\u7f8a\u7531\u5927\u4e95\u592b\u5927\u4eba\u738b\u4e2d\u5de5 拿去在线网站解一下：Unicode编码转换得到一串中文：羊由大井夫大人王中工，很明显是当铺密码，解出来是：9158753624。然后是一个MP3文件，猜测应该是一个MP3隐写，前面那串数字是密码，用MP3stego试一下：在Decode.exe目录下，运行cmd，输入Decode.exe -X apple.mp3 -P 9158753624（MP3文件放到该目录）。运行后生成一个apple.mp3.txt的文件，文件内容为：1Q1RGe3hpYW9fcGluZ19ndW99 拿去base64一下，得到：CTF{xiao_ping_guo} 机密压缩包这题刚开始没什么头绪，试了下伪加密发现不对，百度了一波，发现一篇类似的文章安利一下：crc32碰撞这是关于CRC32碰撞的一道bugku上的题目的writeup，当压缩内容较小时，可以利用里面文件的CRC校验值进行碰撞攻击，下面是解题脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python# -*- coding: UTF-8 -*-import binasciiimport timeimport winsoundstartTime = time.time() keys = [int(&quot;0x5A52D4F4&quot;,16), int(&quot;0x5FA0F28B&quot;,16), int(&quot;0xF899F771&quot;,16), int(&quot;0x957AF788&quot;,16), int(&quot;0xF8208C12&quot;,16)]myRange = [&apos; &apos;, &apos;!&apos;, &apos;&quot;&apos;, &apos;#&apos;, &apos;$&apos;, &apos;%&apos;, &apos;&amp;&apos;, &apos;\&apos;&apos;, &apos;(&apos;, &apos;)&apos;, &apos;*&apos;, &apos;+&apos;, &apos;,&apos;, &apos;-&apos;, &apos;.&apos;, &apos;/&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;:&apos;, &apos;;&apos;, &apos;&lt;&apos;, &apos;=&apos;, &apos;&gt;&apos;, &apos;?&apos;, &apos;@&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;, &apos;[&apos;, &apos;\\&apos;, &apos;]&apos;, &apos;^&apos;, &apos;_&apos;, &apos;`&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;&#123;&apos;, &apos;|&apos;, &apos;&#125;&apos;, &apos;~&apos;]RESULT = &#123;&#125; def getCRC32(str): &apos;&apos;&apos; 计算CRC32 &apos;&apos;&apos; return (binascii.crc32(str) &amp; 0xffffffff)def checkSuccess(keys, mycrc32, words): &apos;&apos;&apos; 检测是否成功匹配 参数 : keys : 所有需要爆破的CRC32值 mycrc32 : 某次计算得到的明文(words)的CRC32 words : 明文 &apos;&apos;&apos; global RESULT for key in keys: if key == mycrc32: RESULT[keys.index(key)] = wordswords = &quot;&quot;counter = 0 oldTime = time.clock()for i in myRange: nowTime = time.clock() print &quot;Trying : &quot; + words + &quot;\t&quot; + &quot;Speed : &quot; + str(counter / (nowTime - oldTime)) + &quot; / s&quot; + &quot;\t&quot; + &quot;Result : &quot; + str(RESULT) # 输出日志 oldTime = nowTime for j in myRange: for k in myRange: words = i + j + k counter += 1 myCRC32 = getCRC32(words) # checkSuccess(keys, myCRC32, words) endTime = time.time()print &quot;Result : &quot; + str(RESULT) print &quot;Cost : &quot; + str(endTime-startTime) + &quot; s&quot; 运行得到：ctf{qwasdzxcqa} 假装安全50分的题目，应该是水题。jpg图片一般先用stegsolve和binwalk试一下，先用binwalk跑一下，得到一个压缩包，里面就是flag.txt。打开看到一串字符串，栅栏加密，密码为2。mcfCrflyS1eot{@eul_ld} 女神的告白题目已经说的很清楚了，暴力破解，前六位为：meimei，用木头字典生成工具写个字典，跑一下得到密码：解压得到flag：moctf{Y0u_@re_A_g00d_man} 蒙娜丽萨的微笑提示说注意图片名字，有道了一下发现是像素的意思，想到图片隐写，老规矩，binwalk先跑一下（比较快），得到一个压缩包，但是没有密码。说明密码还在这张图片里面。提示二说base64，看来密码是base64得到的，但是确不知道从何下手。接下来对图片进行各种尝试，最后试出来：修改图片宽度。图片宽度就是图中红线处，第二行前4字节是长度，接着4字节是宽度。改完之后，发现图片下面有一串字符串，拿去base64，得到密码是：simleisintering。解压得到flag：moctf{Int3resting_piXe1} 未完待续。。。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为入门之HCNA实验]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%8D%8E%E4%B8%BA%E5%85%A5%E9%97%A8%E4%B9%8BHCNA%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[这个实验很久之前就做过了，但是没有总结很快又忘了，今天趁着有空认真总结分析一波。 实验拓扑： 实验需求：12345678910111213141516171819201、IP地址按照拓扑给出的地址信息配置网络设备的IP地址2、链路聚合为了保证SW1和SW2之间的链路可靠性，请通过手工方式实现链路聚合3、STPSW1、SW2和SW3之间为了防止出现环路需要配置STP协议，STP模式为MSTP要求SW1为根网桥，要求SW3的Ethernet 0/0/1端口，在连接网线后立即就可以访问网络4、VLANPC1归属企业网业务网段，属VLAN 100，通过SW3 Access接入SW1连接总部边界路由器AR1，SW1通过VLANif 2接口与AR1的GE0/0/1相连，SW1的GE0/0/1接口类型设置为AccessSW2连接总部边界路由器AR1，SW2通过VLANif 2接口与AR1的GE0/0/1相连，SW2的GE0/0/1接口类型设置为Access5、VRRP为了保证业务网段能够正常访问公司业务，要求在该网段使用VRRP技术，虚拟网关地址为192.168.0.254SW1作为主用网关，当它出现故障的时候，SW2能够快速接替SW1的工作。同时，当SW1的G0/0/1接口失效后，SW2也能够快速接替SW1的工作6、路由为了实现内网到外网的访问，AR1通过静态的方式配置到外网的缺省路由AR1、SW1、SW2之间运行OSPF，配置OSPF进程号为1AR1通过OSPF对内网下发默认路由7、广域网AR1通过PPPoE的方式接入运营商，使用用户名huawei，密码huawei123，拨号获取地址在AR1上配置easyip，使企业内部可以正常访问AR2上的回环口2.2.2.2 我搭建的拓扑图如下： 首先冷静分析一下，第一步应该把Access、Trunk链路和设备的IP地址配好SW3：123456789101112vlan 100int Ethernet0/0/1port link-type access port default vlan 100 int e0/0/3port link-type trunk port trunk pvid vlan 1 #Native vlanport trunk allow-pass vlan allint e0/0/2port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan all SW1：12345678910vlan batch 100 2 #批量创建vlanint g0/0/1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint Vlanif 2ip address 192.168.1.1 30int g0/0/4port link-type access port default vlan 2 这里说明一下，华为设备和思科的不同之处：思科的三层交换机可以打开接口的三层功能（no switchport）然后直接配IP地址，但是华为的设备不行，要先配置SVI口的IP地址，再将该SVI口的vlan配到Access口上。这里还有两个接口没配，因为后面要配链路聚合。 SW2：12345678910vlan batch 2 100int g0/0/1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan all int Vlanif 2ip address 192.168.1.5 30int g0/0/4port link-type access port default vlan 2 R2：12345system-view int g0/0/0ip add 192.168.1.2 30int g0/0/1ip add 192.168.1.6 30 接下来配置链路聚合SW1：12345678int Eth-Trunk 1 创建手工链路port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint g0/0/2eth-trunk 1 #接口调用int g0/0/3eth-trunk 1 SW2：12345678int Eth-Trunk 1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint g0/0/2eth-trunk 1int g0/0/3eth-trunk 1 检验一下成果 接下来配置MSTPSW3：123456789stp enable #打开STP功能，默认关闭stp mode mstp #选择模式stp region-configuration #配置MSTP域region-name 111 #域名revision-level 1 #配置版本号instance 1 vlan 100 #只有一个数据vlan，所以一个实例足矣active region-configuration #激活域int e0/0/1stp disable #关闭不启动MSTP的端口 SW2：12345678910stp enable stp mode mstp stp region-configuration region-name 111revision-level 1instance 1 vlan 100active region-configuration stp instance 1 priority 8192 #次根int g0/0/4stp disable SW1：12345678910stp enable stp mode mstp stp region-configuration region-name 111revision-level 1instance 1 vlan 100active region-configuration stp instance 1 priority 4096 #主根int g0/0/4stp disable 检验一下状态 接下来设置VRRPSW1：1234int vlan 100ip address 192.168.0.1 24vrrp vrid 1 virtual-ip 192.168.0.254vrrp vrid 1 priority 101 #成为主设备 SW2：1234int Vlanif 100ip address 192.168.0.2 24vrrp vrid 1 virtual-ip 192.168.0.254vrrp vrid 1 preempt-mode timer delay 2 #当主设备故障，可延时2秒抢占。 查看状态 接下来配置OSPFSW1：1234ospf router-id 11.11.11.11 #配置模式下设置RIDarea 0 #进入区域再通告network 192.168.1.0 0.0.0.3network 192.168.0.0 0.0.0.255 SW2：1234ospf router-id 22.22.22.22area 0network 192.168.1.4 0.0.0.3network 192.168.0.0 0.0.0.255 R2：12345ospf router-id 1.1.1.1area 0network 192.168.1.0 0.0.0.3network 192.168.1.4 0.0.0.3default-route-advertise always #下发默认路由 在PC上Tracert查看内网是否可以互通分析一下这张图，流量通往192.168.1.6没有直接走192.168.1.2，是因为起了MSTP协议，SW1为主根，所以SW3和SW2之间的链路在逻辑上是断开的。 最后一步，配置PPPoE和easyipR1（PPPoE服务器端）：12345678910111213int Virtual-Template 0 #创建虚拟模板接口ppp authentication-mode chap #认证方式remote address pool haha #为远程PPPoE客户端分配IP地址池hahaip add 12.12.12.1 24int LoopBack 1ip add 2.2.2.2 24ip pool haha #配置地址池gateway-list 12.12.12.1network 12.12.12.0 mask 255.255.255.0int g0/0/0 pppoe-server bind virtual-template 0 #将物理接口与VT接口绑定aaa #进入本地aaa用户数据库local-user huawei password cipher huawei123 #定义用户信息 为了让同为2层协议的以太网承载ppp，那么就需要配置VT虚拟模板（Virtual-Template），VT模板就是让一条链路上可以封装多种同层协议的虚拟接口。因为现在的以太网物理接口已经默认封装了以太网协议，无法再封装其他的WAN协议了，所以才需要VT来模拟一个(WAN)ppp接口，然后封装其他协议如ppp，最后在把VT绑定到物理接口，实现ppp和以太网协议的嵌套。 R2（PPPoE客户端和easyip）：12345678910111213141516171819int Dialer 1 #创建虚拟拨号接口link-protocol ppp #封装ppp协议ppp chap user huaweippp chap password cipher huawei123ip address ppp-negotiate #指定PPPoE客户端自动获取地址dialer user huawei #指定拨号接口所使用的拨号用户dialer bundle 1 #指定拨号接口的编号（用于和物理接口绑定）dialer-group 1 #将拨号接口加入拨号组int g0/0/2pppoe-client dial-bundle-number 1 #物理接口与拨号口绑定dialer-rule #设置拨号口允许通过的流量dialer-rule 1 ip permit mtu 1492 #PPPoE和PPP头加起来8字节，减小MTU为防止出现过大帧acl 2000 #华为标准acl从2000开始rule 10 permit source 192.168.0.0 0.0.0.255int Dialer 1nat outbound 2000 #拨号口上调用ACLip route-static 0.0.0.0 0.0.0.0 Dialer 1 #指向拨号口的静态路由 DCC（拨号控制中心）虚拟拨号接口（dialer）的配置，就是专门用来控制拨号的接口，在这个接口下配置封装协议、ppp认证、ip地址自动获取、dialer接口拨号使用的用户名、pppoe连接建立的等待时间、dialer所属的组、指定dialer接口的编号（这个编号是用来和物理接口绑定时候用到的编号）、nat地址转换等等的配置，都在是该拨号接口下完成的。 完成之后内网就可以访问2.2.2.2]]></content>
      <tags>
        <tag>HCNA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCNP学习心得之双出口NAT]]></title>
    <url>%2F2018%2F03%2F16%2FCCNP%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%B9%8B%E5%8F%8C%E5%87%BA%E5%8F%A3NAT%2F</url>
    <content type="text"><![CDATA[第一次写博客，发个最近做的CCNP实验水一波。 下图为拓扑结构: 实验需求为：内网的172.16.1.1访问外网走上面的链路，192.168.1.1访问外网走下面的链路。当其中一条链路出故障时，可以自动切换线路使得上网不受影响。 先配置IP地址和OSPF：R1：12345678910int f0/0ip add 10.12.12.1 255.255.255.0no shutdownip ospf 1 area 0 #接口下启用OSPFint loopback 1ip add 172.16.1.1 255.255.255.0ip ospf 1 area 0int loopback 2ip add 192.168.1.1 255.255.255.0ip ospf 1 area 0 R2：12345678910int f0/0ip add 10.12.12.2 255.255.255.0no shutdownip ospf 1 area 0int f1/0ip add 23.23.172.2 255.255.255.0no shutdown int f0/1ip add 23.23.192.2 255.255.255.0no shutdown R3：12345678int f0/1ip add 23.23.172.3 255.255.255.0no shutdown int f0/0ip add 23.23.192.3 255.255.255.0no shutdown int loopback 1ip add 211.1.1.1 255.255.255.252 接下来设置ACL（访问控制列表）匹配流量，再用策略路由调用ACL，将匹配到的流量送到相应的接口。设置两个下一跳，当第一条链路故障时第一个下一跳无法到达，可以调用第二个，防止断网。（两个链路都故障还是回去牵网线吧）R2：12345678910access-list 1 permit 172.16.1.0 0.0.0.255access-list 2 permit 192.168.1.0 0.0.0.255route-map pbr permit 10match ip add 1set ip next-hop 23.23.172.3 23.23.192.3route-map pbr permit 20match ip add 2set ip next-hop 23.23.192.3 23.23.172.3int f0/0ip policy route-map pbr #接口下调用策略路由 现在策略路由已经将流量送到了两个出接口了，这时候调用NAT，将地址转换为公网地址然后才能把流量发出去。 R2：12ip nat inside source route-map nat1 interface f1/0 overload ip nat inside source route-map nat2 interface f0/1 overload 这里的NAT采用PAT（端口多路复用）的方式，首先调用第一条NAT，NAT_1又调用了路由图_1，接下来我们去看路由图_1的内容。 Route-map nat1：123route-map nat1 permit 10match ip address 1 2match interface f1/0 路由图_1的意思是：匹配两个ACL匹配到的流量，再匹配接口f0/1，当流量是允许的流量且接口正常时，满足路由图的条件，此时再去调用nat1进行地址转换。当流量不匹配或者端口异常时，不满足路由图的条件，这样nat1就无法生效，此时调用nat2，从另一正常接口发送流量。 路由图_2也是这样：123route-map nat2 permit 10match ip address 1 2match interface f0/1 调用NAT：123456int f0/0ip nat inside int f1/0ip nat outside int f0/1ip nat outside 在R2上下放默认路由：1default-information originate always 下放默认路由后，R1才能访问外网，否则R1没有路由条目，无法知道到外网的流量如何转发。 在R1上写默认路由也一样：1ip route 0.0.0.0 0.0.0.0 10.12.12.2 此时可以分流： 当R2的f1/0接口关闭后：12int f1/0shutdown 根据现象可以看出已经自动切换路径了。 常见问题：1、 ACL写错，流量无法匹配，导致策略路由没有被调用，此时R2收到流量后，直接查找路由表，没有匹配的路由条目，丢包。如：1access-list 1 permit 172.16.1.0 0.0.0.0 2、 策略路由没有在接口上调用，结果如上。 3、 路由图没有匹配接口，当某一接口故障时，无法检测出来，流量被丢弃。 4、 路由图match关系写错，导致不满足路由图条件，IP地址无法转换。如：nat1 permit 10123match ip address 1match ip address 2match interface f0/1 这样写就必须满足，流量既属于列表1页属于列表2，不存在的。。。排查思路：在R3上开启debug ip icmp ,查看地址是否转换。 5、 R2没有下放默认路由或者没有在R1上配默认路由，导致R1无法寻址。 6、 traceroute的时候没有带源地址（172.16.1.1或loopback1）。。。。 7、 静态路由写错。ip route 0.0.0.0 0.0.0.0 f0/0这样写貌似可以，但是当封装MAC地址的时候，要去请求目的MAC地址，R2收到后。。。（谁鸟你啊，劳资也不知道） 跟下一跳的话，直接以下一跳的MAC地址作为目的MAC地址。]]></content>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
</search>
