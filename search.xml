<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[moctf部分题目writeup]]></title>
    <url>%2F2018%2F03%2F21%2Fmoctf%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AEwriteup%2F</url>
    <content type="text"><![CDATA[moctf是理工和集大的大佬们搭建的平台，下面是一些我做出来的题目的writeup。 题目链接 MISC捉迷藏题目给了一个zhuomicang.zip的压缩包，解压得到flag.txt和2.jpg。果断打开flag.txt，里面的内容是：1bW9jdGZ7QnVfeUEwX3QxX2oxYTB9 看这架势应该是base64,拿去在线网站解一下，网址为：http://www1.tc711.com/tool/BASE64.htm解出来看起来像是flag了:1moctf&#123;Bu_yA0_t1_j1a0&#125; 但是仔细看，内容是不要提交，不管了先交，万一出题人想皮一下呢。交上去，报错。那只能看图片了，先用十六进制编辑器看一下，发现图片里面还有一个flag.txt。拿去kali里面binwalk一下，得到一个压缩包，解压得到flag.txt。里面是一串数字：1109 111 99 116 102 123 104 49 100 51 95 97 78 100 95 115 51 51 75 125 猜想应该是十进制转ASCII码，工具解一下，得到flag：moctf{h1d3_aNd_s33K}工具地址：链接：https://pan.baidu.com/s/1IDsoRb40Tv4TAnQxlEAOQQ 密码：kch0 我可是黑客点进链接是一张图片，图片上写了审查元素，按了下F12，没有东西。好吧，保存下来，用十六进制编辑器打开，发现最后面有料：moctf{e4sy_1ma9e_m1sc}。 光阴似箭打开链接，是一张png的动图，保存为gif。然后拿去gif分解网站分解一下得到flag：在线gif分解网站 扫扫出奇迹二维码扫描工具，扫一下得到flag：moctf{qr_code_1s_1n_1t} 杰斯的魔法打开链接，是一串js代码，document.write()方法是用来向网页输出内容的。所以，复制一下扔控制台，得到flag。 百变flag打开链接，发现左上角有一小张图片，但是右键不能保存，返回题目链接，右键保存，得到一张f1ag.png。用十六进制编辑器查看，发现后面有一个f1ag.exe，于是拿到kali分解，提取出压缩包，里面就是f1ag.exe，但是打不开。这时候打开十六进制编辑器（WinHex），在最后面发现重要线索。图片中的数据好像被反过来了，这时候想到提示：特殊文件头+简单字符串编程，应该就是要把数据反回来，再加上文件头。python启动123output = inputFile[::-1]outputFile = open(&apos;output&apos;, &apos;wb&apos;)outputFile.write(output) 运行后得到output文件，用WinHex查看发现已经反回来了，而且文件头已经有了：FFD8FFE1，是JPEG的文件格式，所以加上.jpeg后缀就得到flag了。 歌曲下载压缩包，解压得到apple.mp3和apple.png。图片中间藏着一个二维码，扫描出来是一串Unicode编码：1\u7f8a\u7531\u5927\u4e95\u592b\u5927\u4eba\u738b\u4e2d\u5de5 拿去在线网站解一下：Unicode编码转换得到一串中文：羊由大井夫大人王中工，很明显是当铺密码，解出来是：9158753624。然后是一个MP3文件，猜测应该是一个MP3隐写，前面那串数字是密码，用MP3stego试一下：在Decode.exe目录下，运行cmd，输入Decode.exe -X apple.mp3 -P 9158753624（MP3文件放到该目录）。运行后生成一个apple.mp3.txt的文件，文件内容为：1Q1RGe3hpYW9fcGluZ19ndW99 拿去base64一下，得到：CTF{xiao_ping_guo} 机密压缩包这题刚开始没什么头绪，试了下伪加密发现不对，百度了一波，发现一篇类似的文章安利一下：crc32碰撞这是关于CRC32碰撞的一道bugku上的题目的writeup，当压缩内容较小时，可以利用里面文件的CRC校验值进行碰撞攻击，下面是解题脚本：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python# -*- coding: UTF-8 -*-import binasciiimport timeimport winsoundstartTime = time.time() keys = [int(&quot;0x5A52D4F4&quot;,16), int(&quot;0x5FA0F28B&quot;,16), int(&quot;0xF899F771&quot;,16), int(&quot;0x957AF788&quot;,16), int(&quot;0xF8208C12&quot;,16)]myRange = [&apos; &apos;, &apos;!&apos;, &apos;&quot;&apos;, &apos;#&apos;, &apos;$&apos;, &apos;%&apos;, &apos;&amp;&apos;, &apos;\&apos;&apos;, &apos;(&apos;, &apos;)&apos;, &apos;*&apos;, &apos;+&apos;, &apos;,&apos;, &apos;-&apos;, &apos;.&apos;, &apos;/&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;:&apos;, &apos;;&apos;, &apos;&lt;&apos;, &apos;=&apos;, &apos;&gt;&apos;, &apos;?&apos;, &apos;@&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;, &apos;[&apos;, &apos;\\&apos;, &apos;]&apos;, &apos;^&apos;, &apos;_&apos;, &apos;`&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;&#123;&apos;, &apos;|&apos;, &apos;&#125;&apos;, &apos;~&apos;]RESULT = &#123;&#125; def getCRC32(str): &apos;&apos;&apos; 计算CRC32 &apos;&apos;&apos; return (binascii.crc32(str) &amp; 0xffffffff)def checkSuccess(keys, mycrc32, words): &apos;&apos;&apos; 检测是否成功匹配 参数 : keys : 所有需要爆破的CRC32值 mycrc32 : 某次计算得到的明文(words)的CRC32 words : 明文 &apos;&apos;&apos; global RESULT for key in keys: if key == mycrc32: RESULT[keys.index(key)] = wordswords = &quot;&quot;counter = 0 oldTime = time.clock()for i in myRange: nowTime = time.clock() print &quot;Trying : &quot; + words + &quot;\t&quot; + &quot;Speed : &quot; + str(counter / (nowTime - oldTime)) + &quot; / s&quot; + &quot;\t&quot; + &quot;Result : &quot; + str(RESULT) # 输出日志 oldTime = nowTime for j in myRange: for k in myRange: words = i + j + k counter += 1 myCRC32 = getCRC32(words) # checkSuccess(keys, myCRC32, words) endTime = time.time()print &quot;Result : &quot; + str(RESULT) print &quot;Cost : &quot; + str(endTime-startTime) + &quot; s&quot; 运行得到：ctf{qwasdzxcqa} 假装安全50分的题目，应该是水题。jpg图片一般先用stegsolve和binwalk试一下，先用binwalk跑一下，得到一个压缩包，里面就是flag.txt。打开看到一串字符串，栅栏加密，密码为2。mcfCrflyS1eot{@eul_ld} 女神的告白题目已经说的很清楚了，暴力破解，前六位为：meimei，用木头字典生成工具写个字典，跑一下得到密码：解压得到flag：moctf{Y0u_@re_A_g00d_man} 蒙娜丽萨的微笑提示说注意图片名字，有道了一下发现是像素的意思，想到图片隐写，老规矩，binwalk先跑一下（比较快），得到一个压缩包，但是没有密码。说明密码还在这张图片里面。提示二说base64，看来密码是base64得到的，但是确不知道从何下手。接下来对图片进行各种尝试，最后试出来：修改图片宽度。图片宽度就是图中红线处，第二行前4字节是长度，接着4字节是宽度。改完之后，发现图片下面有一串字符串，拿去base64，得到密码是：simleisintering。解压得到flag：moctf{Int3resting_piXe1} 未完待续。。。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为入门之HCNA实验]]></title>
    <url>%2F2018%2F03%2F19%2F%E5%8D%8E%E4%B8%BA%E5%85%A5%E9%97%A8%E4%B9%8BHCNA%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[这个实验很久之前就做过了，但是没有总结很快又忘了，今天趁着有空认真总结分析一波。 实验拓扑： 实验需求：12345678910111213141516171819201、IP地址按照拓扑给出的地址信息配置网络设备的IP地址2、链路聚合为了保证SW1和SW2之间的链路可靠性，请通过手工方式实现链路聚合3、STPSW1、SW2和SW3之间为了防止出现环路需要配置STP协议，STP模式为MSTP要求SW1为根网桥，要求SW3的Ethernet 0/0/1端口，在连接网线后立即就可以访问网络4、VLANPC1归属企业网业务网段，属VLAN 100，通过SW3 Access接入SW1连接总部边界路由器AR1，SW1通过VLANif 2接口与AR1的GE0/0/1相连，SW1的GE0/0/1接口类型设置为AccessSW2连接总部边界路由器AR1，SW2通过VLANif 2接口与AR1的GE0/0/1相连，SW2的GE0/0/1接口类型设置为Access5、VRRP为了保证业务网段能够正常访问公司业务，要求在该网段使用VRRP技术，虚拟网关地址为192.168.0.254SW1作为主用网关，当它出现故障的时候，SW2能够快速接替SW1的工作。同时，当SW1的G0/0/1接口失效后，SW2也能够快速接替SW1的工作6、路由为了实现内网到外网的访问，AR1通过静态的方式配置到外网的缺省路由AR1、SW1、SW2之间运行OSPF，配置OSPF进程号为1AR1通过OSPF对内网下发默认路由7、广域网AR1通过PPPoE的方式接入运营商，使用用户名huawei，密码huawei123，拨号获取地址在AR1上配置easyip，使企业内部可以正常访问AR2上的回环口2.2.2.2 我搭建的拓扑图如下： 首先冷静分析一下，第一步应该把Access、Trunk链路和设备的IP地址配好SW3：123456789101112vlan 100int Ethernet0/0/1port link-type access port default vlan 100 int e0/0/3port link-type trunk port trunk pvid vlan 1 #Native vlanport trunk allow-pass vlan allint e0/0/2port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan all SW1：12345678910vlan batch 100 2 #批量创建vlanint g0/0/1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint Vlanif 2ip address 192.168.1.1 30int g0/0/4port link-type access port default vlan 2 这里说明一下，华为设备和思科的不同之处：思科的三层交换机可以打开接口的三层功能（no switchport）然后直接配IP地址，但是华为的设备不行，要先配置SVI口的IP地址，再将该SVI口的vlan配到Access口上。这里还有两个接口没配，因为后面要配链路聚合。 SW2：12345678910vlan batch 2 100int g0/0/1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan all int Vlanif 2ip address 192.168.1.5 30int g0/0/4port link-type access port default vlan 2 R2：12345system-view int g0/0/0ip add 192.168.1.2 30int g0/0/1ip add 192.168.1.6 30 接下来配置链路聚合SW1：12345678int Eth-Trunk 1 创建手工链路port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint g0/0/2eth-trunk 1 #接口调用int g0/0/3eth-trunk 1 SW2：12345678int Eth-Trunk 1port link-type trunk port trunk pvid vlan 1port trunk allow-pass vlan allint g0/0/2eth-trunk 1int g0/0/3eth-trunk 1 检验一下成果 接下来配置MSTPSW3：123456789stp enable #打开STP功能，默认关闭stp mode mstp #选择模式stp region-configuration #配置MSTP域region-name 111 #域名revision-level 1 #配置版本号instance 1 vlan 100 #只有一个数据vlan，所以一个实例足矣active region-configuration #激活域int e0/0/1stp disable #关闭不启动MSTP的端口 SW2：12345678910stp enable stp mode mstp stp region-configuration region-name 111revision-level 1instance 1 vlan 100active region-configuration stp instance 1 priority 8192 #次根int g0/0/4stp disable SW1：12345678910stp enable stp mode mstp stp region-configuration region-name 111revision-level 1instance 1 vlan 100active region-configuration stp instance 1 priority 4096 #主根int g0/0/4stp disable 检验一下状态 接下来设置VRRPSW1：1234int vlan 100ip address 192.168.0.1 24vrrp vrid 1 virtual-ip 192.168.0.254vrrp vrid 1 priority 101 #成为主设备 SW2：1234int Vlanif 100ip address 192.168.0.2 24vrrp vrid 1 virtual-ip 192.168.0.254vrrp vrid 1 preempt-mode timer delay 2 #当主设备故障，可延时2秒抢占。 查看状态 接下来配置OSPFSW1：1234ospf router-id 11.11.11.11 #配置模式下设置RIDarea 0 #进入区域再通告network 192.168.1.0 0.0.0.3network 192.168.0.0 0.0.0.255 SW2：1234ospf router-id 22.22.22.22area 0network 192.168.1.4 0.0.0.3network 192.168.0.0 0.0.0.255 R2：12345ospf router-id 1.1.1.1area 0network 192.168.1.0 0.0.0.3network 192.168.1.4 0.0.0.3default-route-advertise always #下发默认路由 在PC上Tracert查看内网是否可以互通分析一下这张图，流量通往192.168.1.6没有直接走192.168.1.2，是因为起了MSTP协议，SW1为主根，所以SW3和SW2之间的链路在逻辑上是断开的。 最后一步，配置PPPoE和easyipR1（PPPoE服务器端）：12345678910111213int Virtual-Template 0 #创建虚拟模板接口ppp authentication-mode chap #认证方式remote address pool haha #为远程PPPoE客户端分配IP地址池hahaip add 12.12.12.1 24int LoopBack 1ip add 2.2.2.2 24ip pool haha #配置地址池gateway-list 12.12.12.1network 12.12.12.0 mask 255.255.255.0int g0/0/0 pppoe-server bind virtual-template 0 #将物理接口与VT接口绑定aaa #进入本地aaa用户数据库local-user huawei password cipher huawei123 #定义用户信息 为了让同为2层协议的以太网承载ppp，那么就需要配置VT虚拟模板（Virtual-Template），VT模板就是让一条链路上可以封装多种同层协议的虚拟接口。因为现在的以太网物理接口已经默认封装了以太网协议，无法再封装其他的WAN协议了，所以才需要VT来模拟一个(WAN)ppp接口，然后封装其他协议如ppp，最后在把VT绑定到物理接口，实现ppp和以太网协议的嵌套。 R2（PPPoE客户端和easyip）：12345678910111213141516171819int Dialer 1 #创建虚拟拨号接口link-protocol ppp #封装ppp协议ppp chap user huaweippp chap password cipher huawei123ip address ppp-negotiate #指定PPPoE客户端自动获取地址dialer user huawei #指定拨号接口所使用的拨号用户dialer bundle 1 #指定拨号接口的编号（用于和物理接口绑定）dialer-group 1 #将拨号接口加入拨号组int g0/0/2pppoe-client dial-bundle-number 1 #物理接口与拨号口绑定dialer-rule #设置拨号口允许通过的流量dialer-rule 1 ip permit mtu 1492 #PPPoE和PPP头加起来8字节，减小MTU为防止出现过大帧acl 2000 #华为标准acl从2000开始rule 10 permit source 192.168.0.0 0.0.0.255int Dialer 1nat outbound 2000 #拨号口上调用ACLip route-static 0.0.0.0 0.0.0.0 Dialer 1 #指向拨号口的静态路由 DCC（拨号控制中心）虚拟拨号接口（dialer）的配置，就是专门用来控制拨号的接口，在这个接口下配置封装协议、ppp认证、ip地址自动获取、dialer接口拨号使用的用户名、pppoe连接建立的等待时间、dialer所属的组、指定dialer接口的编号（这个编号是用来和物理接口绑定时候用到的编号）、nat地址转换等等的配置，都在是该拨号接口下完成的。 完成之后内网就可以访问2.2.2.2]]></content>
      <tags>
        <tag>HCNA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCNP学习心得之双出口NAT]]></title>
    <url>%2F2018%2F03%2F16%2FCCNP%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%B9%8B%E5%8F%8C%E5%87%BA%E5%8F%A3NAT%2F</url>
    <content type="text"><![CDATA[第一次写博客，发个最近做的CCNP实验水一波。 下图为拓扑结构: 实验需求为：内网的172.16.1.1访问外网走上面的链路，192.168.1.1访问外网走下面的链路。当其中一条链路出故障时，可以自动切换线路使得上网不受影响。 先配置IP地址和OSPF：R1：12345678910int f0/0ip add 10.12.12.1 255.255.255.0no shutdownip ospf 1 area 0 #接口下启用OSPFint loopback 1ip add 172.16.1.1 255.255.255.0ip ospf 1 area 0int loopback 2ip add 192.168.1.1 255.255.255.0ip ospf 1 area 0 R2：12345678910int f0/0ip add 10.12.12.2 255.255.255.0no shutdownip ospf 1 area 0int f1/0ip add 23.23.172.2 255.255.255.0no shutdown int f0/1ip add 23.23.192.2 255.255.255.0no shutdown R3：12345678int f0/1ip add 23.23.172.3 255.255.255.0no shutdown int f0/0ip add 23.23.192.3 255.255.255.0no shutdown int loopback 1ip add 211.1.1.1 255.255.255.252 接下来设置ACL（访问控制列表）匹配流量，再用策略路由调用ACL，将匹配到的流量送到相应的接口。设置两个下一跳，当第一条链路故障时第一个下一跳无法到达，可以调用第二个，防止断网。（两个链路都故障还是回去牵网线吧）R2：12345678910access-list 1 permit 172.16.1.0 0.0.0.255access-list 2 permit 192.168.1.0 0.0.0.255route-map pbr permit 10match ip add 1set ip next-hop 23.23.172.3 23.23.192.3route-map pbr permit 20match ip add 2set ip next-hop 23.23.192.3 23.23.172.3int f0/0ip policy route-map pbr #接口下调用策略路由 现在策略路由已经将流量送到了两个出接口了，这时候调用NAT，将地址转换为公网地址然后才能把流量发出去。 R2：12ip nat inside source route-map nat1 interface f1/0 overload ip nat inside source route-map nat2 interface f0/1 overload 这里的NAT采用PAT（端口多路复用）的方式，首先调用第一条NAT，NAT_1又调用了路由图_1，接下来我们去看路由图_1的内容。 Route-map nat1：123route-map nat1 permit 10match ip address 1 2match interface f1/0 路由图_1的意思是：匹配两个ACL匹配到的流量，再匹配接口f0/1，当流量是允许的流量且接口正常时，满足路由图的条件，此时再去调用nat1进行地址转换。当流量不匹配或者端口异常时，不满足路由图的条件，这样nat1就无法生效，此时调用nat2，从另一正常接口发送流量。 路由图_2也是这样：123route-map nat2 permit 10match ip address 1 2match interface f0/1 调用NAT：123456int f0/0ip nat inside int f1/0ip nat outside int f0/1ip nat outside 在R2上下放默认路由：1default-information originate always 下放默认路由后，R1才能访问外网，否则R1没有路由条目，无法知道到外网的流量如何转发。 在R1上写默认路由也一样：1ip route 0.0.0.0 0.0.0.0 10.12.12.2 此时可以分流： 当R2的f1/0接口关闭后：12int f1/0shutdown 根据现象可以看出已经自动切换路径了。 常见问题：1、 ACL写错，流量无法匹配，导致策略路由没有被调用，此时R2收到流量后，直接查找路由表，没有匹配的路由条目，丢包。如：1access-list 1 permit 172.16.1.0 0.0.0.0 2、 策略路由没有在接口上调用，结果如上。 3、 路由图没有匹配接口，当某一接口故障时，无法检测出来，流量被丢弃。 4、 路由图match关系写错，导致不满足路由图条件，IP地址无法转换。如：nat1 permit 10123match ip address 1match ip address 2match interface f0/1 这样写就必须满足，流量既属于列表1页属于列表2，不存在的。。。排查思路：在R3上开启debug ip icmp ,查看地址是否转换。 5、 R2没有下放默认路由或者没有在R1上配默认路由，导致R1无法寻址。 6、 traceroute的时候没有带源地址（172.16.1.1或loopback1）。。。。 7、 静态路由写错。ip route 0.0.0.0 0.0.0.0 f0/0这样写貌似可以，但是当封装MAC地址的时候，要去请求目的MAC地址，R2收到后。。。（谁鸟你啊，劳资也不知道） 跟下一跳的话，直接以下一跳的MAC地址作为目的MAC地址。]]></content>
      <tags>
        <tag>CCNP</tag>
      </tags>
  </entry>
</search>
